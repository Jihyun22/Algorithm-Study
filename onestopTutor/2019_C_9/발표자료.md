# 2020년도 15회 E-PPER 대비 기출 풀이 (1)

E-PPER(Ewha Power ProgrammER) 프로그래밍 경진대회

2019년도 제 13회 EPEER C부문 기출 풀이

*담당: 컴공 17권지현*

# **![direct hit](https://paper.dropboxstatic.com/static/img/ace/emoji/1f3af.png?version=6.0.0)** **9번 길 걷다 돈 줍기** **(동적계획법)**

## **[문제 설명]**

- 이화는 길을 걷고 있는데, 어느 날 산신령이 나타나서 길에 돈을 일렬로 놓으며 “돈을 마음껏 주워가라. 단, 연속해서 3개의 돈을 가질 수 없다.”라고 말하였다. 이화가 최대 주울 수 있는 돈의 액수를 구하는 프로그램을 작성하시오.
- 다음과 같이 길에 돈이 있을 경우, 최대 주울 수 있는 돈은 37원이 된다.

| 5    | 7    | 10   | 1    | 2    | 10   | 10   | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

## **[입력 형식]**

- 첫 번째 줄에 입력받을 돈의 개수 n을 입력한다. ( 1 ≤ n ≤ 30000 )
- 두 번째 줄에 n 개의 돈의 액수 m을 공백으로 구분하여 입력한다. ( 1 ≤ m ≤ 10 )

## **[출력 형식]**

\- 주울 수 있는 돈의 최대 금액을 출력한다.

# ![magnifying glass tilted left](https://paper.dropboxstatic.com/static/img/ace/emoji/1f50d.png?version=6.0.0) **풀이**

동적계획법은 점화식을 세우는 것이 가장 중요합니다. 본 풀이에서는 동적계획법의 점화식 작성 방법을 살펴본 후 테스트 케이스로 자세히 설명하겠습니다.

## **1. 배열 선언**

돈의 액수가 저장되는 money[]와 계산 결과가 누적 저장되는 배열 dp[]를 선언합니다.

- dp[i] = i번째 까지 탐색 하였을 때 돈의 액수의 최댓값

## **2. 부분 문제 정의**

점화식을 세우는 요령은 문제를 단순화하여 접근하는 것 입니다. 부분 문제를 정의하겠습니다.

- - n>=1

- : dp[0] = money[0]

- - n>=2

- : dp[1] = money[0] + money[1]

- - n>=3

- : dp[2] = max(dp[1], max(money[1]+money[2], dp[0]+money[2]))

- n이 3인 경우, i-2와 i번째, i-1과 i번째, i-2와 i-1번째의 돈의 액수의 합 중 더 큰 값이 dp[i]에 저장됩니다.

## **3. 점화식 세우기**

n이 3 이상인 경우, 최대 주울 수 있는 돈의 액수는

max(dp[i-1],  max(dp[i-3]+money[i-1]+money[i],  dp[i-2]+money[i])) 입니다. 

그림으로 살펴보겠습니다.

1. **dp[i-1]**

| i-3  | i-2  | i-1                           | i    |
| ---- | ---- | ----------------------------- | ---- |
|      |      | *money[:i-1]까지 계산된 dp값* |      |

1. **dp[i-3]+money[i-1]+money[i]**

| i-3                           | i-2  | i-1        | i        |
| ----------------------------- | ---- | ---------- | -------- |
| *money[:i-3]까지 계산된 dp값* |      | money[i-1] | money[i] |

1. **dp[i-2]+money[i]**

| i-3  | i-2                           | i-1  | i        |
| ---- | ----------------------------- | ---- | -------- |
|      | *money[:i-2]까지 계산된 dp값* |      | money[i] |

해당 절차를 반복하고 dp를 통해 최댓값을 탐색합니다. 

## **4. 정리**

테스트 케이스로 위 절차를 자세하게 살펴보겠습니다. 

| *#1*     | *TEST CASE*         |
| -------- | ------------------- |
| *input*  | 85 7 10 1 2 10 10 8 |
| *output* | 37                  |

아래 표는 테스트 케이스의 연산 순서 입니다.

| dp                              | dp[i-1] | dp[i-3]+money[i-1]+money[i] | dp[i-2]+money[i] | dp[i] |
| ------------------------------- | ------- | --------------------------- | ---------------- | ----- |
| (5,                             | -       | -                           | -                | 5     |
| (5, 7                           | 5       | -                           | -                | 12    |
| (5, 7, 10,                      | 12      | -                           | -                | 17    |
| (5, **7, 10**, 1,               | **17**  | 5+10+1 = 16                 | 12+1 = 13        | 17    |
| (5, **7, 10**, 1, **2,**        | 17      | 12 + 1 + 2 = 15             | 17+2 = **19**    | 19    |
| (5, **7, 10,** 1, **2, 10,**    | 19      | 17 + 2+ 10 = **29**         | 17+10 = 27       | 29    |
| (5, **7, 10,** 1, 2, **10, 10** | 29      | 17 + 10 + 10 = **37**       | 19 + 10 = 29     | 37    |
| (5, 7, 10, 1, 2, 10, 10, 8)     | 37      | 19 + 10 + 8 = 37            | 29 + 8 = 37      | 37    |

최종 결과값은 dp[n-1]에 저장됩니다.