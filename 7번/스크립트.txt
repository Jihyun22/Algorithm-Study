2020년도 제 15회 이퍼 대비 C부문 기출 풀이입니다.

19년도 C기출문제 중 7번 풀이를 시작하겠습니다.

7번은 회문을 만드는 문제로 완전 탐색을 이용한 문제입니다.
n개의 요소를 갖는 배열 a를 회문으로 만들기 위해
인접한 요소끼리 합하는 방식으로 반복하여 수정하며,
최소한의 배열 수정 횟수를 출력하면 됩니다.

풀이입니다. 본 풀이에서는 완전 탐색을 해결하는 방법 중 재귀법을 사용하겠습니다.
기본 아이디어는 
배열의 양쪽 끝 값이 같은지 비교를 반복하고, 
같지 않을 경우 한쪽 끝 값에서 인접요소를 합하거나, 다른 쪽 끝 값에서 인접 요소를 합한 후,
끝 값을 갱신하여 비교 연산을 반복하는 것입니다.

첫번째 테스트 케이스 4, 1, 3, 2 의 연산 순서를 살펴보겠습니다.

첫번째로 비교 대상을 선정합니다. 회문은 중앙을 기준으로 배열의 요소가 대칭을 이루어야 합니다. 비교 대상인 양쪽 끝 값을 정의하겠습니다.  편의상 앞쪽의 포인터를 a, 뒤쪽의 포인터를 b로 명시하겠습니다.

비교 결과 a는 4, b는 2로 같지 않으므로
다음 단계에서 각 끝 값의 인접 요소를 합하는 경우를 고려하겠습니다.

끝 값에서 인접 요소를 합하는 경우는 두 경우입니다. 두 경우를 전부 탐색하는 것 보다, ‘인접 요소를 합’을 구한다는 조건’을 고려하여 array[a]와 array[b]중 작은 값 쪽에서 인접 요소를 합하는 경우만 고려하는 것이 보다 효율적입니다.

본 케이스에서는 a=5, b=2에서 a가 더 크므로, b값을 갱신하여 비교 연산을 진행합니다.

편의상 표에서 array항목은 갱신 전 값을 제외하고 비교 대상만 나타냈으니 참고바랍니다.

3와 2을 더해 b-1 값을 5로 교체해줍니다. 

1번 교체가 진행되었지만 a와 b값이 같지 않습니다. 위 과정을 재귀문 호출로 반복 수행하면 총 2번 교체되어야 회문의 조건에 성립하는 것을 확인할 수 있습니다.
연산 과정을 정리하면 다음의 표와 같습니다.

마지막으로 종료 조건입니다.
재귀법에서는 종료 조건 설정에 유의해야 합니다. a를 앞 쪽 포인터로 설정한 만큼, a값이 b보다 큰 경우, 함수가 종료됩니다. 또한 포인터가 만나는 경우, 즉 a==b인 경우 역시 함수가 종료됩니다.

이 테스트케이스는 i=4일 때 a > b로 함수가 종료되고 결과값이 리턴됩니다.

수도코드입니다.
반복 횟수는 전역변수로 선언되어 있다고 가정하겠습니다.
재귀문에서 a가 b보다 큰 경우, a가 b와 같은 경우 함수는 종료됩니다.

그렇지 않은 경우, a와 b가 가리키는 값을 비교합니다.
같은 경우 a값과 b값을 각각 +1, -1로 갱신한 후 재귀함수를 호출합니다.
같이 다른 경우, 더 작은 쪽에서 인접요소를 합한 후 함수를 호출하여 비교 연산을 반복합니다.

이상 문제 설명을 마치겠습니다. 다음은 실제 코드 작성에 대해 설명하겠습니다.

---------

실제 코드 작성에 대해 설명하겠습니다.

15회 이퍼는 작년과 달리 온라인 플랫폼 프로그래머스를 사용하는 만큼 비슷한 플랫폼인 구름에서 작성하도록 하겠습니다.

참고로, 솔루션 함수 형태를 사용하는 프로그래머스에서는 본 코드에서 사용자 입출력 저장 부문인 main함수를 삭제한 후 주어진 형식에 맞게 일부 수정해야 합니다.

우선 사용할 변수를 선언하겠습니다. 
주어진 배열을 저장할 배열과
반복 횟수를 전역변수로 선언합니다.
//변수 선언
int arr[10];
int answer = 0;

다음으로 사용할 함수를 선언합니다. 이 함수는 main에서 재귀적으로 호출될 계산부 함수 입니다.
//함수 선언
void cal(int a, int b);

main함수에서는 사용자 입력을 처리하고
재귀함수 호출문을 작성합니다.
배열의 포인터로 활용되는 a와 b의 초기값은 각각 0과 n-1로 설정합니다.
int main(void){
    int a, b, n;
    scanf("%d", &n);
    for(int i=0; i<n; i++)
        scanf("%d", &arr[i]);

a와 b의 초기값은 각각 0과 n-1로 설정합니다.
    a=0;
    b=n-1;
    cal(a, b);

출력 형식에 맞게 프린트 문을 작성하면 완료입니다.
    printf("%d\n", answer);
    return 0;
}

다음은 cal함수입니다.
우선 종료조건을 작성합니다.
void cal(int a, int b){
    if(a>=b)
        return;

포인터 a와 b값을 받아 배열의 요소를 비교합니다. 
    if(arr[a] == arr[b])
        cal(a+1, b-1);
같은 경우, a, b값을 갱신한 후 재귀함수를 호출합니다.
다른 경우
값이 작은 쪽에서 인접 수를 더해 갱신하고, 반복회수를 +1 한 후 함수를 호출합니다.
    if(arr[a] == arr[b])
        cal(a+1, b-1);
    else{
        if(arr[a] > arr[b]){
        	arr[b-1] += arr[b];
            answer++;
            cal(a, b-1);
            
        }
        else{
            arr[a+1] += arr[a];
            answer++;
            cal(a+1, b);
        }
    }
}

이상으로 코드 작성이 끝났습니다.

미리 저장해 둔 테스트 케이스로 확인해 보겠습니다.

정상 값이 출력되었습니다.
본 문제의 구름 테스트 환경 링크와 발표자료, 소스코드는 추가로 안내하겠습니다.

이상 9번 기출 풀이를 마치겠습니다.