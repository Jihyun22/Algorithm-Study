# 2020년도 15회 E-PPER 대비 기출 풀이 (2)

E-PPER(Ewha Power ProgrammER) 프로그래밍 경진대회

2019년도 제 13회 EPEER C부문 기출 풀이

*담당: 컴공 17권지현*

# **![direct hit](https://paper.dropboxstatic.com/static/img/ace/emoji/1f3af.png?version=6.0.0)** **7번 회문 만들기** **(완전탐색)**

## **[문제 설명]**

- 이화는 회문(palindrome: 앞으로 읽으나 뒤로 읽으나 동일한 것)을 너무 좋아한다.
- n개의 요소를 갖는 배열 A도 A[i] = A[n-1-i] 인 회문을 만들고 싶어 한다.(배열 인덱스는 0부터 시작) 즉, {1, 3, 1}, {1, 2, 2, 1}과 같은 모양의 배열이다.
- 이화를 위해 회문이 아닌 배열은 다음 규칙에 따라 수정해서 회문을 만들 수 있게 했다. 수정 규칙은 n개의 요소를 갖는 배열이 있을 때, 인접한 요소끼리 합해서 n-1 개의 요소를 갖는 배열로 만드는 방법이다.
- 예를 들어 {1, 3, 5, 7}인 배열은 인접한 두 요소 1, 3을 더 해 {4, 5, 7}인 배열로 수정할 수 있다. 처음에 회문이 아닌 배열이 주어졌을 때, 몇 번의 수정을 통해 회문이 만들어지는지 그 횟수를 구하는 프로그램을 작성하시오

## **[입력 형식]**

- 첫 번째 줄에 배열을 구성하는 요소의 개수 n을 입력한 다. ( 1  ≤ n ≤ 10 )
- 두 번째 줄에 n 개의 숫자 배열 X 를 공백으로 구분하여 입력 한다. ( 1 ≤ X[i] ≤ 100 )

## **[출력 형식]**

- 회문을 만들기까지 최소한의 배열 수정 횟수를 출력한다.

# ![magnifying glass tilted left](https://paper.dropboxstatic.com/static/img/ace/emoji/1f50d.png?version=6.0.0) **풀이**

완전탐색과 관련된 문제입니다. 본 풀이에서는 재귀법을 사용합니다.

기본 아이디어는

**![keycap: 1](https://paper.dropboxstatic.com/static/img/ace/emoji/0031-20e3.png?version=6.0.0)** **배열의 양쪽 끝 값이 같은지 비교를 반복하고,** 

**![keycap: 2](https://paper.dropboxstatic.com/static/img/ace/emoji/0032-20e3.png?version=6.0.0)** **같지 않을 경우 한쪽 끝 값에서 인접요소를 합하거나, 다른 쪽 끝 값에서 인접 요소를 합한 후,**

**![keycap: 3](https://paper.dropboxstatic.com/static/img/ace/emoji/0033-20e3.png?version=6.0.0)** **끝 값을 갱신하여 1) 과정을 반복합니다.**

첫번째 테스트케이스(4, 1, 3, 2)의 연산 순서를 살펴보겠습니다.

## **1. 비교 대상 선정**

회문은 중앙을 기준으로 배열의 요소가 대칭 구조를 이뤄야 합니다. 비교 대상인 양쪽 끝 값을 정의하겠습니다.  편의상 앞쪽의 포인터를 a, 뒤쪽의 포인터를 b로 표시하겠습니다.

| *index* | *array*                | array[a] | *b*  |
| ------- | ---------------------- | -------- | ---- |
| *value* | ( **4**, 1, 3, **2** ) | 4        | 2    |

4와 2이 같지 않으므로, 끝 값에서 인접 요소를 합치는 경우를 고려해야 합니다.

## **2. 재귀법**

끝 값에서 인접요소를 합치는 경우는 

1. 1. 포인터 a에서 인접 요소를 합하기 : array[a+1] + array[a] =array[a+1]
   2. 포인터 b에서 인접 요소를 합하기array[b-1] + array[b] =array[b-1]

두 경우로 나뉩니다.

두 경우를 전부 탐색하는 것 보다, ‘*인접* *요소를 합을 구한다*’는 조건을 고려하여 array[a]와 array[b]중 작은 값 쪽에서 인접 요소를 합하도록 작성합니다. 마찬가지로 array[a]와 array[b]가 같은 경우, a값과 b값을 각각 a+1, b-1로 갱신하도록 작성하면 더욱 효율적으로 처리할 수 있습니다.

본 케이스에서는 a=5, b=2에서 a가 더 크므로, b값을 갱신하여 비교 연산을 진행합니다.

- - **array[b-1] + array[b] =array[b-1]**

- 3와 2을 더해 b-1 값을 5로 교체해줍니다.

| *index* | *array*             | *array[a]* | *array[b]* |
| ------- | ------------------- | ---------- | ---------- |
| *value* | ( **4,** 1, **5 )** | 4          | 5          |

- 1번 교체가 진행되었지만 a와 b값이 같지 않습니다. 위 과정을 재귀문 호출로 반복 수행하면 총 2번 교체되어야 회문의 조건에 성립하는 것을 확인할 수 있습니다.

- 연산 과정을 정리하면 다음의 표와 같습니다.

| *i*  | *array*        | *array[a]* | *array[b]* | *교체 횟수* |
| ---- | -------------- | ---------- | ---------- | ----------- |
| 0    | ( 4, 1, 3, 2 ) | -          | -          | 0           |
| 1    | ( 4, 1, 3, 2 ) | 4 (a=0)    | 2 (b=3)    | 0           |
| 2    | ( 4, 1, 5 )    | 4 (a=0)    | 5 (b=2)    | 1           |
| 3    | ( 5, 5 )       | 5 (a=1)    | 5 (b=2)    | 2           |

## 3**. 종료 조건**

재귀법에서는 종료 조건 설정에 유의해야 합니다. a를 앞 쪽 포인터로 설정한 만큼, a값이 b보다 큰 경우, 함수가 종료됩니다. 또한 포인터가 만나는 경우, 즉 a==b인 경우 역시 함수가 종료됩니다.

| *i*  | *array*                | *array[a]* | *array[b]* | *교체 횟수* |
| ---- | ---------------------- | ---------- | ---------- | ----------- |
| 0    | ( 4, 1, 3, 2 )         | -          | -          | 0           |
| 1    | ( **4**, 1, 3, **2** ) | 4 (a=0)    | 2 (b=3)    | 0           |
| 2    | ( **4**, 1, **5** )    | 4 (a=0)    | 5 (b=2)    | 1           |
| 3    | ( 5, 5 )               | 5 (a=1)    | 5 (b=2)    | 2           |
| 4    | ( 5, 5 )               | (a=2)      | (b=1)      | 종료        |

이 테스트케이스는 i=4일 때 a > b로 함수가 종료되고 결과값이 리턴됩니다.

## **[수도코드]**

```c
void cal(a, b){
  //항상 a는 b보다 작아야 함
  if a > b
    return;
  if a == b
    return;
  else
    if arr[a] == arr[b]
      cal(a+1, b-1)
    if else arr[a] > arr[b]
      arr[b-1]값 갱신
      cal(a, b-1)
      반복횟수 +1
    else
      arr[a+1]값 갱신
      cal(a+1, b)
      반복횟수 +1
}
```